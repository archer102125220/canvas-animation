<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>贪吃蛇小游戏</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        html, body {
            width: 100%;
            height: 100%;
        }

        body {
            position: relative;
            background: lightgrey;
        }

        canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform-origin: center;
            transform: translate3d(-50%, -50%, 0);
            border: 1px dashed grey;
        }
    </style>
</head>
<body>
<script>
  const CANVAS_WIDTH = 800
  const CANVAS_HEIGHT = 800

  const canvas = document.createElement('canvas')
  canvas.width = CANVAS_WIDTH
  canvas.height = CANVAS_HEIGHT
  document.body.appendChild(canvas)
  const ctx = canvas.getContext('2d')

  function checkCollision (box1, box2) {
    return !(box1.right <= box2.left || box1.left >= box2.right || box1.top >= box2.bottom || box1.bottom <= box2.top)
  }

  const DIR = {
    UP: 'up',
    LEFT: 'left',
    DOWN: 'down',
    RIGHT: 'right',
  }
  const KEY_CODE = {
    W: 87,
    A: 65,
    S: 83,
    D: 68,
  }

  const Snake = function () {
    this.score = 0
    this.crashed = false // 撞上自己
    this.headSize = { width: 20, height: 20 } // 头的宽/高
    this.partSize = { width: 20, height: 20 } // 每一节宽/高
    this.headPos = { x: CANVAS_WIDTH / 4, y: CANVAS_HEIGHT / 2 } // 头部的位置
    this.bodyLength = 200 // 身体长度
    this.disPlayBodyLength = 200 // 身体长度
    this.bodyParts = [
      { direction: DIR.RIGHT, x: this.headPos.x - 200, y: this.headPos.y, width: 200, height: this.partSize.height }
    ] // 身体组成部分的数组
    this.direction = DIR.RIGHT
    this.speed = 100 // 每秒移动距离
    this.foodPos = { x: 0, y: 0 } // 食物的位置
    this.foodSize = { width: 20, height: 20 } // 食物的尺寸
    this.eating = false
    this.headBox = {
      top: this.headPos.y,
      right: this.headPos.x + this.headSize.width,
      bottom: this.headPos.y + this.headSize.height,
      left: this.headPos.x,
    }
    this.foodBox = {
      top: this.foodPos.y,
      right: this.foodPos.x + this.foodSize.width,
      bottom: this.foodPos.y + this.foodSize.height,
      left: this.foodPos.x,
    }

    this.turn = function (keyCode) {
      if ((snake.direction === DIR.DOWN && keyCode === KEY_CODE.S) || (snake.direction === DIR.DOWN && keyCode === KEY_CODE.W)
        || (snake.direction === DIR.RIGHT && keyCode === KEY_CODE.D) || (snake.direction === DIR.RIGHT && keyCode === KEY_CODE.A)
        || (snake.direction === DIR.UP && keyCode === KEY_CODE.W) || (snake.direction === DIR.UP && keyCode === KEY_CODE.S)
        || (snake.direction === DIR.LEFT && keyCode === KEY_CODE.A) || (snake.direction === DIR.LEFT && keyCode === KEY_CODE.D)) {
        return false
      }
      const bodyPart = { x: this.headPos.x, y: this.headPos.y, width: this.partSize.width, height: this.partSize.height }
      switch (keyCode) {
        case KEY_CODE.W: // 上 W
          this.direction = DIR.UP
          this.headPos.y -= this.headSize.height
          bodyPart.direction = DIR.UP
          break
        case KEY_CODE.A: // 左 A
          this.direction = DIR.LEFT
          this.headPos.x -= this.headSize.width
          bodyPart.direction = DIR.LEFT
          break
        case KEY_CODE.S: // 下 S
          this.direction = DIR.DOWN
          this.headPos.y += this.headSize.height
          bodyPart.direction = DIR.DOWN
          break
        case KEY_CODE.D: // 右 D
          this.direction = DIR.RIGHT
          this.headPos.x += this.headSize.width
          bodyPart.direction = DIR.RIGHT
          break
      }
      // 增加转角长度然后减小
      this.disPlayBodyLength += this.partSize.width
      this.bodyParts.unshift(bodyPart)
    }

    this.move = function (delta) {
      if (this.disPlayBodyLength - this.bodyLength > 1) {
        this.disPlayBodyLength = this.bodyLength + (this.disPlayBodyLength - this.bodyLength) * 0.5
      }
      else {
        this.disPlayBodyLength = this.bodyLength
      }
      // 身体
      const bodyParts = []
      let nextHeadPos = Object.assign({}, this.headPos)
      const distance = delta / 1000 * this.speed
      switch (this.direction) {
        case DIR.UP: // 上
          nextHeadPos.y -= distance
          break
        case DIR.LEFT: // 左
          nextHeadPos.x -= distance
          break
        case DIR.RIGHT: // 下
          nextHeadPos.x += distance
          break
        case DIR.DOWN: // 右
          nextHeadPos.y += distance
          break
      }
      const nextHeadBox = {
        top: nextHeadPos.y,
        right: nextHeadPos.x + this.headSize.width,
        bottom: nextHeadPos.y + this.headSize.height,
        left: nextHeadPos.x,
      }
      let addedLength = 0
      if (this.bodyParts.length > 0) {
        let curPart
        let curPartBox
        let delta = 0
        // 临时长度（加上转角增加的部分）
        const bodyPartLength = this.disPlayBodyLength
        // const bodyPartLength = this.disPlayBodyLength + this.bodyParts.length * this.partSize.width
        let end = false
        for (let i = 0; !end && i < this.bodyParts.length; i++) {
          curPart = this.bodyParts[i]
          // 该部分方向向右
          if (curPart.direction === DIR.RIGHT) {
            if (i === 0) { curPart.width += distance }
            delta = addedLength + curPart.width - bodyPartLength
            // 若超过了总长度则截取
            if (delta >= 0) {
              curPart.x += delta
              curPart.width -= delta
              bodyParts.push(curPart)
              end = true
            }
            else {
              addedLength += curPart.width
              bodyParts.push(curPart)
            }
          }
          // 该部分方向向下
          else if (curPart.direction === DIR.DOWN) {
            if (i === 0) {
              curPart.height += distance
            }
            delta = addedLength + curPart.height - bodyPartLength
            // 若超过了总长度则截取
            if (delta >= 0) {
              curPart.y += delta
              curPart.height -= delta
              bodyParts.push(curPart)
              end = true
            }
            else {
              addedLength += curPart.height
              bodyParts.push(curPart)
            }
          }
          // 该部分方向向左
          else if (curPart.direction === DIR.LEFT) {
            if (i === 0) {
              curPart.x -= distance
              curPart.width += distance
            }
            delta = addedLength + curPart.width - bodyPartLength
            // 若超过了总长度则截取
            if (delta >= 0) {
              curPart.width -= delta
              bodyParts.push(curPart)
              end = true
            }
            else {
              addedLength += curPart.width
              bodyParts.push(curPart)
            }
          }
          // 该部分方向向上
          else if (curPart.direction === DIR.UP) {
            if (i === 0) {
              curPart.y -= distance
              curPart.height += distance
            }
            delta = addedLength + curPart.height - bodyPartLength
            // 若超过了总长度则截取
            if (delta >= 0) {
              curPart.height -= delta
              bodyParts.push(curPart)
              end = true
            }
            else {
              addedLength += curPart.height
              bodyParts.push(curPart)
            }
          }
          curPartBox = {
            top: curPart.y,
            right: curPart.x + curPart.width,
            bottom: curPart.y + curPart.height,
            left: curPart.x,
          }
          if (i !== 0 && !this.crashed && checkCollision(nextHeadBox, curPartBox)) {
            console.log(`和第${i + 1}截尾巴撞上了`)
            console.log('score:', this.score)
            this.crashed = true
          }
        }
      }
      this.headPos = nextHeadPos
      this.bodyParts = bodyParts
      this.headBox = nextHeadBox
    }

    // 和eat拆分开来是因为willEat必须每次循环调用，eat每帧调用，也许会穿过food
    this.willEat = function () {
      if (!this.eating && checkCollision(this.headBox, this.foodBox)) {
        this.eating = true
      }
    }

    this.eat = function () {
      if (this.eating) {
        this.bodyLength += this.foodSize.width
        this.disPlayBodyLength += this.foodSize.width
        this.createFood()
        this.speed *= 1.05
        this.eating = false
        this.score += 1
      }
    }

    this.createFood = function () {
      const foodPos = {
        x: Math.random() * (CANVAS_WIDTH - this.foodSize.width),
        y: Math.random() * (CANVAS_HEIGHT - this.foodSize.height),
      }
      const foodBox = {
        top: foodPos.y,
        right: foodPos.x + this.foodSize.width,
        bottom: foodPos.y + this.foodSize.height,
        left: foodPos.x,
      }
      // 头部是否碰撞
      if (checkCollision(this.headBox, foodBox)) {
        this.createFood()
      }
      else {
        // 循环遍历蛇身体，如果有碰撞则重新计算
        // for (let i = 0; i < this.bodyParts.length; i++) {
        //   ?? this.createFood()
        // }
        this.foodPos = foodPos
        this.foodBox = foodBox
      }
    }

    this.draw = function () {
      ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT)
      // 蛇头
      ctx.fillStyle = 'rgba(0,10,10,0.5)'
      ctx.fillRect(this.headPos.x, this.headPos.y, this.headSize.width, this.headSize.height)
      // 蛇身
      ctx.fillStyle = 'rgba(0,80,80,0.5)'
      if (this.bodyParts.length > 0) {
        for (let i = 0; i < this.bodyParts.length; i++) {
          ctx.fillRect(this.bodyParts[i].x, this.bodyParts[i].y, this.bodyParts[i].width, this.bodyParts[i].height)
        }
      }

      // 食物
      ctx.fillStyle = 'rgba(0,2,127,1)'
      ctx.fillRect(this.foodPos.x, this.foodPos.y, this.foodSize.width, this.foodSize.height)
      // ctx.end()
    }

    this.update = function (delta) {
      this.eat()
      this.move(delta)
      this.draw()
    }
  }

  const snake = new Snake()
  snake.createFood()

  window.addEventListener('keydown', function (e) {
    const keyCode = e.keyCode
    if (keyCode === 32) {
      return stop ? play() : pause()
    }
    [KEY_CODE.W, KEY_CODE.A, KEY_CODE.S, KEY_CODE.D].indexOf(keyCode) !== -1 && snake.turn(keyCode)
  })

  let fps = 60  // 每秒帧数
  let lockFps = true // 锁定帧率
  let interval = 1000 / fps  // 连续帧之间间隔（理论）
  let stop = false  // 停止动画
  let timeLast = performance.now()  // 上一帧时间
  let delta = 0  // 连续帧之间间隔（实际）

  let distance = 0
  const tick = function (timestamp) {
    if (stop) return false
    snake.willEat()
    delta = timestamp - timeLast
    if (lockFps) {
      if (delta > interval) {
        snake.update(delta)
        timeLast = timestamp
      }
    }
    else {
      snake.update(delta)
      timeLast = timestamp
    }
    !snake.crashed && requestAnimationFrame(tick)
  }

  const pause = function () {
    stop = true

  }

  const play = function () {
    stop = false
    timeLast = performance.now()
    requestAnimationFrame(tick)
  }

  requestAnimationFrame(tick)

</script>

</body>
</html>
